%%% Local Variables:
%%% TeX-command-extra-options: "-shell-escape"
%%% mode: latex
%%% TeX-master: t
%%% End:
\documentclass{beamer}
\usepackage{caption}
\usepackage{minted}
\usepackage{tikz}
\usepackage{xcolor}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=1.5cm, minimum height=0.6cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=1.5cm, minimum height=0.5cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [circle, radius=2.5cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
\usepackage[labelformat=simple]{subcaption}

\usetheme{Singapore}
\title{Program Design}
%\subtitle{in Racket}
%\author{Peter Campora}
%\institute{ULL}
%\date{\today}

%This lectures introduces the fundamentals of design
\begin{document}
\begin{frame}
\titlepage
\end{frame}

\begin{frame}
  ``Let's talk about design\\
  Let's talk about programmers\\
  Let's talk about code\\
  Let's talk about bugs\\
  Let's talk about design''\\\\
  -Celine Dion\\
  --Peter Campora
\end{frame}

\begin{frame}
  \frametitle{Why Does Code Quality Matter?}
  \large If the program works, who cares...\\\\
  \pause
  \huge \textbf{People will read your code later!}\\\\
  \pause
  \large Ever heard of the Y2K problem? In the 20th century, digits were used to represent years...
  \begin{itemize}
  \item<4->  So, when the 21st century came, the years 1900 and 2000 would be handled identically.
  \item<5-> A ton of applications had to be updated to avoid bugs. Consider if dates were stored in poorly named int variables.
  \item<6-> Well documented code makes such refactorings easier.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{It Starts With a D}
  \large What is the thing that most determines the structure of a program?\\\\
  \pause
  \begin{center}
    \includegraphics[width=0.4\textwidth]{images/data.jpg}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Domains and Data}
  The two D's of software development are domains and data.
  \begin{itemize}
  \item<2-> The quantity, 5, means different things in different \emph{domains}. For a game, 4 might be the number of pixels an object should move per clock tick. For furniture website, 4 might represent the number of legs on a chair.
  \item<3-> Information in English is usually given to programmers to indicate the structure of the domain. Our job is to turn this information into \emph{data}
    representations. 
  \item<4-> After we have data representations for our domain, a program becomes a matter of data transformation.
  \item<5-> The final data produced by the program is some sort of information about our domain.
  \item<6-> If the final data is 42, this might be some height in pixels, the number of units sold, the meaning of life...etc.
  \end{itemize}
\end{frame}

\defverbatim[colored]\dataDef{
\begin{minted}{racket}
  ; A Temperature is a Number. 
  ; interpretation represents Celsius degrees
\end{minted}
}

\begin{frame}
  \frametitle{Data Interpretation}
  For now, we will specify the interpretation of data in comments (later we will define data types).
  \begin{itemize}
  \item<2-> We will call these data definitions. Here's an example:
  \item<3-> \dataDef
  \item<4-> This specifies that the numbers produced by our program (or function) represent Celsius degrees
  \item<5-> Such a specification rules out ``cold'' as a temperature but not -400 (which is not a real C temp)
  \item<6-> Later, we will learn to put such specifications on data, but for now our english descriptions suffice
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Design Process}
  Keeping Data Interpretation in mind, let's turn to our program design process
  \begin{enumerate}
  \item<2-> Express how you wish to represent information as data. A one-line comment for specifying \emph{data interpretations} suffices.
  \item<3-> Write down a signature, a statement of purpose, and a function header.
    \begin{itemize}
    \item<4-> A \emph{signature} communicates the domain and codomain of your function. For example: \mintinline{racket}{; Number Number -> Number}
    \item<5-> A \emph{statement of purpose} communicates what the function produces and how it produces the answer
    \item<6-> A \emph{function header} is merely a stub definition for the function with a name, parameters, and a trivial body: \mintinline{racket}{(define (add x y) 0)}
    \end{itemize}    
  \end{enumerate}
\end{frame}

\defverbatim[colored]\squareExample{
\begin{minted}{racket}
    ; Number -> Number
    ; computes the area of a square with side len 
    ; given: 2, expect: 4
    ; given: 7, expect: 49
    (define (area-of-square len) 0)
\end{minted}
}

\defverbatim[colored]\squareTests{
\begin{minted}{racket}
    (sqr 2); gives: 4
    (sqr 7); gives: 49
\end{minted}
}

\begin{frame}
  \frametitle{The Design Process (cont.)}
  \begin{enumerate}
    \setcounter{enumi}{2}
  \item Create \emph{functional examples} that illustrate the expected input and output behaviors of a function. Consider a function that computes the square of a number: \squareExample
  \item<2-> \emph{Take inventory} for the program. See what is given and what needs to be computed. Basically, each function header indicates
    what is needed and then we start to skeleton the body based on the parameters:
    \begin{itemize}
    \item<3-> \mintinline{racket}{(define (area-of-square len) (... len ...))}
    \item<4-> The dots indicate where the function needs to be fleshed out.    
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{The Design Process (cont.)}
  \begin{enumerate}
    \setcounter{enumi}{4}
  \item<2-> Now we finally \emph{code}. Based on our inventory and functional examples, we should have some idea of what to replace the ... with.
    For the program we've been discussing, our function body becomes \mintinline{racket}{(sqr len)}, where the second ... is removed.
  \item<3-> The final step is \emph{testing} the definition based on our functional examples.
    We'll first verify the correctness of this definition in Racket. But if we made a mistake it could be one of three kinds:
    \begin{itemize}
    \item<4-> The functional examples were wrong.
    \item<5-> The function definition was wrong and needs to be rewritten.
    \item<6-> Both the examples and the definition were wrong.
    \item<7-> In any case, we have to back and verify that steps 3 was done correctly, and if it was, then we head back to step 5. Otherwise, fix the examples and retest.
    \end{itemize}    
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Homework 2}
  For our second homework, I want you to repeat writing certain functions from the first homework but using the
  design process.
  \begin{enumerate}
  \item Design the function string-first, which extracts the first character from a non-empty string. Don’t worry about empty strings.
  \item Design the function string-last, which extracts the last character from a non-empty string.
  \item Design the function image-area, which counts the number of pixels in a given image.
  \item Design the function string-rest, which produces a string like the given one with the first character removed.
  \item Design the function string-remove-last, which produces a string like the given one with the last character removed. 
  \end{enumerate}
\end{frame}


\begin{frame}
  \frametitle{Programming in Different Domains}
  There are two different kinds of domain knowledge that programmers typically deal with.
  \begin{itemize}
  \item<2-> One is knowledge from external domains. In Lafayette alone, there are programmers working on programs dealing with pharmaceutical operations, food  delivery, ambulance services, jewelry, oil field technology, insurance claims, and more. So  how do programmers figure out how to write functions
    for dealing with these different domains? One necessary skill is to learn math, which is common to many domains. The other is to learn communication skills so that you can pick up necessary skills for new domains by communicating with experts in these fields.
  \item<3-> The other domain knowledge that is used is knowledge of library functions. Knowing what things are already written for you greatly speeds up development.
    Don't reinvent the wheel.
  \end{itemize}  
\end{frame}

\begin{frame}
  \frametitle{From Functions to Programs}
  It's rare that a program consists of a single function definition unless it's trivial or poorly written. So why does the need for multiple functions arise?
  \begin{itemize}
  \item<2-> When designing an interactive program, we need separate functions for handling different events, like handling a mouse click versus a keyboard press.
  \item<3-> For batch programs, auxiliarly functions are needed when solving some subpart of the overall problem. For example, we need a function to square numbers
    when defining a batch program that computes the area of a circle when given its radius.
  \item<4-> Although not a necessity, often we encounter that the same computation is needed twice, and copying code is tedious and error-prone.
  \item<5-> For these reasons for needing functions, programmers should keep a \emph{wish list} of functions that they need to define.
  \end{itemize}
  
\end{frame}

\begin{frame}
  \frametitle{Wish Lists}
  \begin{center}
    \includegraphics[width=0.25\textwidth]{images/christmas-list.jpeg}
  \end{center}
  \begin{itemize}
  \item<2-> Here's an algorithm for writing programs with a wish list.
  \item<3-> If writing a batch program, put the main function on the list. If writing an interactive program, put the event handling functions, etc. on the wish list.
  \item<4-> Take an item off of the wish list and start designing it.
  \item<5-> When designing the function, if it seems that another function is necessary to finish the current design, then put this new function on the wish list and
    start designing it.
  \item<6-> Keep designing functions on the wish list until no more remain. After this, the program should be complete.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Everyone's Favorite Activity}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{images/testing.png}
  \end{center}
  \begin{itemize}
  \item<2-> Love it or hate it, testing is an essential part of software development, as we want our software to behave correctly and predictably. 
  \item<3-> Testing functions by loading the program and using the repl with manual input values is a tedious and brittle way to ensure the validity of programs.
  \item<4-> So, we want a facility to mechanize testing, which Racket (and most languages) provides.
  \item<5-> What are we waiting for? Let's get cooking (testing)!
  \end{itemize}
\end{frame}

\defverbatim[colored]\testProgram{
\begin{minted}{racket}
  ; Number -> Number 
  ; converts Fahrenheit temperatures to Celsius
  ; given 32, expect 0
  ; given 212, expect 100
  ; given -40, expect -40
  (define (f2c f)
    (* 5/9 (- f 32)))
\end{minted}
}

\defverbatim[colored]\tests{
\begin{minted}{racket}
    (check-expect (f2c -40) -40)
    (check-expect (f2c 32) 0)
    (check-expect (f2c 212) 100)
\end{minted}
}

\begin{frame}
  \frametitle{Check Your Expectations}
  Let us consider testing a Fahrenheit to Celsius conversion program:
  \testProgram
  \begin{itemize}
  \item<2-> Our tests should be created from our functional examples.
  \item<3-> Using rackets \mintinline{racket}{check-expect} form, we can write the appropriate tests:
    \tests
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Testing (cont.)}
  \begin{itemize}
  \item  The general expression \mintinline{racket}{(check-expect exp-to-test expected-value)} says that the expression \mintinline{racket}{exp-to-test}
    should evaluate to \mintinline{racket}{expected-value}, and otherwise the test fails.
  \item<2-> To run tests under Racket, we add the expression \mintinline{racket}{(test)} to our file.
  \item<3-> You can add test expressions before a function is even defined, and it will be fine.
  \item<4-> You can also test images in Dr Racket:
    \includegraphics[width=0.4\textwidth]{images/test-image.png}
  \item<5-> Write lots of tests so that you can be confident in the correctness of your programs as you develop them!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{How to Design Interactive Programs}
  Our previous discussion of event-driven bigbang programs was done in an ad hoc way. Now we discuss how to systematically design such programs.
  \begin{itemize}
  \item<2-> To start designing world programs, you must first create a data definition for all possible states.
  \item<3-> Then comes writing stubs for each of the event handling functions.
  \item<4-> Then the stubs for the exit and rendering functions.
  \item<5-> Putting these all together creates our wish list.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{An Example Wish List}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/wish-list.png}
  \end{center}
\end{frame}

\defverbatim[colored]\constants{
\begin{minted}{racket}
    (define WIDTH-OF-WORLD 200) ;physical constant
    ...
    (define WHEEL
      (circle WHEEL-RADIUS "solid" "black")) ;graphical constant
\end{minted}
}

\defverbatim[colored]\worldState{
\begin{minted}{racket}
      ; A WorldState is a Number.
      ; interpretation the number of pixels between
      ; the left border of the scene and the car
\end{minted}
}

\begin{frame}
  \frametitle{Interactive Design By Example}
  Let's illustrate the rest of the design for an interactive program by example.
  We will have three big steps to illustrate and one small one.
  \begin{itemize}
  \item<2-> Let's animate a car moving across the screen, moving to the right 3 pixels per clock tick. 
  \end{itemize}
  \begin{enumerate}
  \item<3-> For all properties of the world that do not change, introduce constants.
    We will introduce constants for the description for the car. These are separated into two parts, graphical and physical constants:
    \constants
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Interactive Design By Example (cont.)}
  \begin{enumerate}
    \setcounter{enumi}{1}
  \item<1-> Other properties do change over time and events and determine the state of the world. We must give an interpretation of what our world state means.
    \begin{itemize}
    \item<2-> So, based on our problem description what changes over time?
    \item<3-> Right, so our worldState is the position of the car:
      \worldState
    \end{itemize}
  \item<4-> After defining constants and the interpretation of our world state,
    we can start defining the relevant functions that will be on our wish list.
    \begin{itemize}
    \item<5-> Typically our wish list starts with our event handling functions, something to indicate when the program terminates, and our render function
    \item<6-> For this program, there is only 1 event that we need to handle. What is it?
    \end{itemize}
  \end{enumerate}
\end{frame}

\defverbatim[colored]\tock{
\begin{minted}{racket}
  ; WorldState -> WorldState
  ; adds 3 to x to move the car right 
  (define (tock x) x)
\end{minted}
}

\defverbatim[colored]\render{
\begin{minted}{racket}
  ; WorldState -> Image
  ; places the image of the car x pixels from 
  ; the left margin of the BACKGROUND image 
  (define (render x) BACKGROUND)
\end{minted}
}

\begin{frame}
  \frametitle{Interactive Design By Example (cont.)}
  Since the problem description doesn't specify anything about user
  input, we only have to handle clock events. Moreover, we don't have a specification that the car should stop at the right edge of the screen, so no termination function is needed. So what functions are on our wishlist that we need to apply our design process to?
  \begin{enumerate}
  \item<2-> We need a function \mintinline{racket}{tock} for handling clock ticks
  \item<3-> We need a function \mintinline{racket}{render} to draw the scene.
  \end{enumerate}
  \begin{itemize}
  \item<4-> Skeletoning out our tock function:
    \tock
  \item<5-> Our render function:
    \render
  \end{itemize}
\end{frame}

\defverbatim[colored]\mainProg{
\begin{minted}{racket}
; WorldState -> WorldState
; launches the program from some initial state 
(define (main ws)
   (big-bang ws
     [on-tick tock]
     [to-draw render]))
\end{minted}
}

\begin{frame}
  \frametitle{Interactive Design By Example (cont.)}
  For our final step we need to design our main function that makes
  use of our tock and render functions. The structure of main is
  straightforward from the rest of the process so far. 
  \begin{itemize}
  \item<2-> \mainProg
  \item<3-> And that's it for skeletoning out this example! First, define constants,
    second give a world state interpretation, third start defining relevant
    functions on the wishlist, and fourth define the main function as a
    big bang expression. Now we use the design process for functions to finish
    the definitions for tock and render.
  \end{itemize}
\end{frame}

\defverbatim[colored]\tockSkeleton{
\begin{minted}{racket}
  ;   given: 20, expect 23
  ;   given: 78, expect 81
  (define (tock ws) (... ws ...))
\end{minted}
}

\begin{frame}
  \frametitle{Interactive Design By Example (cont.)}
  Using step 4 of our design process for functions, let us give input
  and output examples for our tock function. and skeleton out the rest of the body.
  \begin{itemize}
  \item<2-> \tockSkeleton
  \item<3-> After this, we finish the body of the function as
    \mintinline{racket}{(define (tock ws) (+ ws 3))}
  \item<4-> Finally, we can add tests to verify the correctness of the function:
    \mintinline{racket}{(check-expect (tock 20) 23)} and \mintinline{racket}{(check-expect (tock 78) 81)}.
  \item<5-> And similarly we can use our process to finish the render function.
    For now, we move on to making an interesting modification to the program.
  \end{itemize}  
\end{frame}

\defverbatim[colored]\moveCar{
\begin{minted}[fontsize=\footnotesize]{racket}
  ; Number Number Number String -> Number
  ; If the mouse event is a click down,
  ; move the x-coordinate of the world state
  ; Given: 30 10 20 "button-down" Expect: 10
  ; Given: 30 10 20 "enter" Expect: 30
  ; Given: 30 10 20 "move" Expect: 30
  (define (move-car car-position x-click y-click click-kind) ...)
\end{minted}
}

\begin{frame}
  \frametitle{Real Interaction}
  Let's modify our car program so that a car can teleport to where a user clicks
  on the canvas (the x-coordinate, y won't change).
  \begin{itemize}
  \item<2-> What will we need to add to our big-bang expression to handle this
    new criteria?
  \item<3-> Right, we need to add a function for the on-click handler.
  \item<4-> But what arguments will click events pass to our function?
  \item<5-> It passes the x-coordinate, y-coordinate, and whether or not the
    mouse clicked down, was released, or was moved.
  \item<6-> So, we need something like:
    \moveCar
  \end{itemize}
\end{frame}

\defverbatim[colored]\moveCar{
\begin{minted}[fontsize=\footnotesize]{racket}
  (define (move-car car-position x-click y-click click-kind) 
    (cond
      [(string=? click-kind "button-down") x-click]
      [else car-position]))
\end{minted}
}

\begin{frame}
  \frametitle{Real Interaction (cont.)}
  Based on our functional examples, the body of move-car needs to be a
  conditional expression that depends on the string given:
  \begin{itemize}
  \item<2-> \moveCar
  \item<3-> Then the last thing we need to do is add:
    \mintinline{racket}{[on-click move-car]} to the big-bang expression.
  \item<4-> So, our modifications to this program was relatively simple. Why?
    Two reasons:
    \begin{enumerate}
    \item<5-> Our program is separated into a \emph{model} that represents
      the position of the car and the state of the world and a \emph{view}
      that renders the scene based on the model.
    \item<6-> The design recipes clearly relate a change in the problem description
      to an event that needs to be handled.
    \end{enumerate}
  \end{itemize}
\end{frame}

\defverbatim[colored]\mouseEnum{
\begin{minted}{racket}
  ; A MouseEvt is one of these Strings:
  ; – "button-down"
  ; – "button-up"
  ; – "drag"
  ; – "move"
  ; – "enter"
  ; – "leave"
\end{minted}
}

\begin{frame}
  \frametitle{Intervals, Enumerations, and Itemizations}
  So far our programs haven't had a lot of different states that they could
  be in that complicate the conditional logic of the program.
  \begin{itemize}
  \item<2-> We've already discussed \mintinline{racket}{cond} expressions.
  \item<3-> Now we will consider \emph{enumerations} which represent the alternative states our data can be in.
  \item<4-> Remember in previous programs that we have to inspect strings
    to discover if the correct mouse or key event happened
  \item<5-> \mouseEnum
  \end{itemize}
\end{frame}

\defverbatim[colored]\trafficEnum{
\begin{minted}{racket}
  ; A TrafficLight is one of the following Strings:
  ; – "red"
  ; – "green"
  ; – "yellow"
  ; interpretation the three strings represent the three 
  ; possible states that a traffic light may assume 
\end{minted}
}

\begin{frame}
  \frametitle{Enumerations}
  We sometimes need to define our own enumerations to describe
  the state of our application. For example, we can describe
  the state of a traffic light as follows:
  \begin{itemize}
  \item<2-> \trafficEnum
  \item<3-> So, let's say that now we want a program to animate the changing
    of a traffic light, starting from a red light
  \item<4-> Although I'm pretty sure we all know how traffic lights transition,
    I'll draw a state machine on the board.
  \item<5-> How does this state machine translate to code?    
  \end{itemize}
\end{frame}

\defverbatim[colored]\trafficTransition{
\begin{minted}{racket}
  ; TrafficLight -> TrafficLight
  ; yields the next state given current state s
  (check-expect (traffic-light-next "red") "green")
  (define (traffic-light-next s)
    (cond
      [(string=? "red" s) "green"]
      [(string=? "green" s) "yellow"]
      [(string=? "yellow" s) "red"]))
\end{minted}
}

\begin{frame}
  \frametitle{Enumerations (cont.)}
  The conditional nature of state and transitions in a state machine
  directly translate to a function with a conditional expression.
  \begin{itemize}
  \item<2-> \trafficTransition
  \item<3-> We should probably add more tests to verify that our definition
    works, but we will skip this for now.
  \item<4-> Homework: Write a big bang program to animate a continuous
    traffic light transition sequence (don't worry if it flashes through the
    colors far too rapidly).
  \end{itemize}
\end{frame}

\defverbatim[colored]\keyEnum{
\begin{minted}{racket}
  ; A KeyEvent is one of: 
  ; – 1String
  ; – "left"
  ; – "right"
  ; – "up"
  ; – ...
\end{minted}
}



\begin{frame}
  \frametitle{Enumerations (cont.)}
  An important thing about enumerations to remember is that there are
  only a finite amount of alternatives to consider. 
  \begin{itemize}
  \item<2-> The bad thing about our approach so far is that
    we have to specify our data alternatives in comments and then
    when encountering a function taking an enumeration as input, we
    write a cond expression handling each alternative.
  \item<3-> Consider key events as an enumeration:
    \keyEnum
  \end{itemize}
\end{frame}

\defverbatim[colored]\keHandler{
\begin{minted}{racket}
  ; WorldState KeyEvent -> ...
  (define (handle-key-events w ke)
    (cond
      [(= (string-length ke) 1) ...]
      [(string=? "left" ke) ...]
      [(string=? "right" ke) ...]
      [(string=? "up" ke) ...]
      [(string=? "down" ke) ...]
      ...))
\end{minted}
}

\begin{frame}
  \frametitle{Handling Enumerations Systematically}
  The specification of our enumeration \emph{directly} gives rise
  to the structure of our handler.
  \begin{itemize}
  \item<2-> Cond handles each key input:
    \keHandler
  \item<3-> It's like \emph{algebra}. If you need to solve a quadratic
    equation, use the quadratic formula...
  \item<4-> If data is represented as an enumeration, write a function
    that matches against the alternatives of the enumeration.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Enumerations By Example}
  It's pretty common that we only have to consider a subset of the
  overall set of possible enumerations for some state. Let's illustrate
  this by considering a program that only uses a subset of the key events:
  \begin{itemize}
  \item<2-> Design a key-event handler that moves a red dot left or right on a horizontal line in response to pressing the left and right arrow keys.
  \item<3-> We must differentiate the left and right arrow keys from
    other key presses.
  \item<4-> Let's employ our design process!
  \end{itemize}
\end{frame}

\defverbatim[colored]\keInterp{
\begin{minted}[fontsize=\footnotesize]{racket}
  ;; A Position is a natural number
  ;; whose interpretation measures distance from the left axis.  
\end{minted}
}

\defverbatim[colored]\keHeader{
\begin{minted}{racket}
  ; Position KeyEvent -> Position
  ; computes the next location of the ball 
  (define (key-handler position key-event) ...)
\end{minted}
}

\defverbatim[colored]\keTests{
\begin{minted}{racket}
  (check-expect (key-handler 13 "left") 8)
  (check-expect (key-handler 13 "right") 18)
  (check-expect (key-handler 13 "a") 13)
\end{minted}
}

\begin{frame}
  \frametitle{Designing a Key Handler}
  What's the first step to designing this function
  \begin{itemize}
  \item<2->That's right, design a data interpretation for our world state.
  \item<3-> \keInterp
  \item<4-> Now, we write a signature, a statement of purpose, and a 
    function header.
  \item<5-> \keHeader
  \item<6-> Now we need to give an example of some expected input and output pairs.
  \item<7-> \keTests
  \end{itemize}
\end{frame}

\defverbatim[colored]\keDef{
\begin{minted}{racket}
  (define (key-handler p k)
    (cond
      [(= (string-length k) 1)
       p]
      [(string=? "left" k)
       (- p 5)]
      [(string=? "right" k)
       (+ p 5)]
      [else p]))
\end{minted}
}

\begin{frame}
  \frametitle{Designing a Key Handler (cont.)}
  Now we can start fleshing out the definition of \mintinline{racket}{key-handler}.
  \begin{itemize}
  \item<2-> Based on our examples, and specification of
    the KeyEvent enumeration we need a cond expression.
  \item<3-> \keDef
  \end{itemize}
\end{frame}

\defverbatim[colored]\keNew{
\begin{minted}{racket}
  (define (key-handler p k)
    (cond
      [(string=? "left" k)
       (- p 5)]
      [(string=? "right" k)
       (+ p 5)]
      [else p]))
\end{minted}
}

\begin{frame}
  \frametitle{Designing a Key Handler (cont.)}
  The previous program was designed based on the idea that we
  consider each case of our enumeration and add a cond clause.
  Is there anything wrong with it?
  \mintinline{racket}{key-handler}.
  \begin{itemize}
  \item<2-> We didn't need the first clause for checking for Characters
    and can refactor it as follows:
  \item<3-> \keNew
  \item<4-> In general, we should program in such a matter, writing
    a working version first and refactoring to a cleaner definition later.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Intervals and Itemizations}
  Most of you should be familiar with the idea of an interval. It is simply
  a range of numbers that should be considered, without a need for
  explicit enumeration.
  Writing conditions to deal
  with different ranges should not be difficult to you by now. So, I will
  focus more on \emph{itemizations} which generalize enumerations and intervals.
  \begin{itemize}
  \item<2-> An itemization can contain enumerations and intervals or any
    combination of data possibilities from separate domains.
  \item<3-> An example of a function whose signature uses an
    itemization is \mintinline{racket}{string->number}, with
    the signature \mintinline{racket}{String -> NorF}
  \item<4-> A \mintinline{racket}{NorF} is either \mintinline{racket}{false}
    or an element of type \mintinline{racket}{Number}
  \item<5-> Let's start writing some function that uses the \mintinline{racket}{NorF} itemization to illustrate how it's done.
  \end{itemize}
\end{frame}

\defverbatim[colored]\condAdd{
\begin{minted}{racket} 
  (cond
    [(false? x) ...]
    [else ...])
\end{minted}
}

\defverbatim[colored]\addThree{
\begin{minted}{racket}
; NorF -> Number
; adds 3 to the given number; 3 otherwise
(check-expect (add3 #false) 3)
(check-expect (add3 0.12) 3.12)
(define (add3 x)
  (cond
    [(false? x) 3]
    [else (+ x 3)]))
\end{minted}
}

\begin{frame}
  \frametitle{Using Itemizations}
  Let's consider writing a program that adds three to an input
  of type \mintinline{racket}{NorF}. It should treat \mintinline{racket}{false}
  as 0, similar to many languages (like Python).
  \begin{itemize}
  \item<2-> What does my signature look like?
  \item<3-> \mintinline{racket}{; NorF -> Number}
  \item<4-> What should we replace ''...'' with in this test?
    \mintinline{racket}{(check-expect (add3 false) ...)}
  \item<5-> \mintinline{racket}{(check-expect (add3 false) 3)}
  \item<6-> A test for checking numbers is straightforward:
    \mintinline{racket}{(check-expect (add3 0.12) 3.12)}
  \item<7-> The body of our function will have to check what the type
    of the data we received is:
  \item<8-> \condAdd
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Using Itemizations (cont.)}
  It should be straightforward to define the rest of the program after this:
  \pause
  \addThree
  \pause
  There's something a bit deeper going on with Itemizations that we'll
  get into later...but for now we should just write more programs!
\end{frame}

\defverbatim[colored]\LRCD{
\begin{minted}{racket}
    ; An LRCD (for launching rocket countdown) is one of:
    ; – "resting"
    ; – a Number between -3 and -1
    ; – a NonnegativeNumber 
    ; interpretation a grounded rocket, in countdown mode,
    ; a number denotes the number of pixels between the
    ; top of the canvas and the rocket (its height)
\end{minted}
}

\defverbatim[colored]\rocketConstants{
\begin{minted}[fontsize=\footnotesize]{racket}
    (define SCENE-HEIGHT 300) ; distances in pixels 
    (define SCENE-WIDTH  100)
    (define YDELTA 3)
 
    (define BACKGROUND  (empty-scene SCENE-WIDTH SCENE-HEIGHT))
    (define ROCKET (rectangle 5 30 "solid" "red"))
 
    (define CENTER (/ (image-height ROCKET) 2))
\end{minted}
}

\begin{frame}
  \frametitle{Return to NASA}
  Let's write a program to launch a Rocket with a countdown!
  The countdown starts when the space bar is pressed and counts down from
  3. After reaching 0, liftoff is achieved and the rocket flies 3 pixels
  per clock tick upwards.
  \begin{itemize}
  \item<2-> This program is more involved than previous ones we wrote.
  \item<3-> Let us start by following our program design recipe and
    defining our global constants.
  \item<4-> \rocketConstants
  \item<5-> Our next step is to give our data interpretation for the program,
    which is more involved.
  \end{itemize}
\end{frame}

\defverbatim[colored]\rocketWish{
\begin{minted}[fontsize=\footnotesize]{racket}
  ; LRCD -> Image
  ; renders the state as a resting or flying rocket 
  (define (show x)
    BACKGROUND)
 
  ; LRCD KeyEvent -> LRCD
  ; starts the countdown when space bar is pressed, 
  ; if the rocket is still resting 
  (define (launch x ke)
    x)
 
  ; LRCD -> LRCD
  ; raises the rocket by YDELTA,
  ;  if it is moving already 
  (define (fly x)
    x)
\end{minted}
}

\defverbatim[colored]\showTestOne{
\begin{minted}{racket}
  (check-expect (show "resting")
    (place-image ROCKET 10 SCENE-HEIGHT BACKGROUND))
\end{minted}
}

\begin{frame}
  \frametitle{Return to NASA (cont.)}
  So position is obviously part of the state, but the state
  should also indicate if the space bar has not been pressed. And we also
  need state for representing the countdown, an interval. What does this look like?
  \begin{itemize}
  \item<2-> \LRCD
  \end{itemize}  
\end{frame}

\begin{frame}
  \frametitle{Return to NASA (cont.)}
  Since this is a big-bang program, we create a wishlist of functions for
  handling key presses, handling clock ticks, and rendering an image. It should
  look something like the following:
  \pause
 \rocketWish    
\end{frame}

\defverbatim[colored]\showTestTwo{
\begin{minted}[fontsize=\footnotesize]{racket}
  (check-expect
   (show -2)
   (place-image (text "-2" 20 "red")
                10 (* 3/4 WIDTH)
                (place-image ROCKET 10 SCENE-HEIGHT BACKGROUND)))
\end{minted}
}

\defverbatim[colored]\showTestThree{
\begin{minted}{racket}
  (check-expect
   (show 53)
   (place-image ROCKET 10 53 BACKGROUND))
\end{minted}
}

\begin{frame}
  \frametitle{Show the Rocket!}
  Before we start developing our rendering function, we must provide some
  functional examples.
  \begin{itemize}
  \item<2-> \showTestOne
  \item<3-> This test is straightforward, the rocket should remain at the
    bottom of the screen
  \item<4-> Let's make a test for when the countdown is happening. We will
    assume that the countdown is drawn at (10, 3/4*width).
  \item<5-> \showTestTwo
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Show the Rocket! (cont.)}
  We need one last test to illustrate what the rocket should do once
  it has launched.
  \begin{itemize}
  \item<2-> \showTestThree
  \item<3-> Quickly evaluating our expected results in DrRacket
    shows that our rocket is halfway into the ground...
  \item<4-> Always try to specify your tests correctly, or it
    is hard to debug programs. Let's fix our tests.
  \item<5-> These input and output examples illustrate that our
    \mintinline{racket}{show} function must have a cond expression
    handling the different types of data in our LRCD itemization.
  \end{itemize}
\end{frame}

\defverbatim[colored]\showSkeleton{
\begin{minted}{racket}
    (define (show x)
      (cond
        [(string? x) ...]
        [(<= -3 x -1) ...]
        [(>= x 0) ...]))
\end{minted}
}

\begin{frame}
  \frametitle{Show the Rocket! (cont.)}
  So, let's make a skeleton for show:
  \begin{itemize}
  \item<2-> \showSkeleton
  \item<3-> Recall that each cond clause corresponds to some part of the
    itemization, as did our tests.
  \item<4-> By looking at our first test, we can easily finish the first
    cond clause
  \item<5-> \mintinline{racket}{(place-image ROCKET 10 SCENE-HEIGHT BACKGROUND)}
  \end{itemize}
\end{frame}

\defverbatim[colored]\countDown{
\begin{minted}[fontsize=\footnotesize]{racket}
    (place-image 
      (text (number->string x) 20 "red") 10 (* 3/4 SCENE-WIDTH) 
        (place-image ROCKET 10 SCENE-HEIGHT BACKGROUND))
\end{minted}
}

\begin{frame}
  \frametitle{Show the Rocket! (cont.)}
  Now we need to finish the last two clauses. Notice that between -3 and -1,
  we want to display a  number in the countdown, and so we need some way of
  converting these values to strings.
  \begin{itemize}
  \item<2-> Anyone recall how to get a string from a number in Racket?
  \item<3-> With \mintinline{racket}{number->string}, we can now produce
    the countdown text and place the rocket at the bottom of the image.
  \item<4-> \countDown
  \item<5-> The last clause is nice and simple and places the rocket at $\mintinline{racket}{x} - \mintinline{racket}{CENTER}$ when $\mintinline{racket}{x} \ge 0$.
  \item<6-> \mintinline{racket}{(place-image ROCKET 10 (- x CENTER) BACKGROUND)}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Launch!}
  Whew finishing fly took a while! And we still have two more functions
  to develop! Let's develop our key-event handling function
  \mintinline{racket}{launch} first.
  \begin{itemize}
  \item<2-> As usual let's start developing our functional examples.
  \item<3-> \mintinline{racket}{(check-expect (launch "resting" " ") -3)}
  \item<4-> \mintinline{racket}{(check-expect (launch "resting" "a") "resting")}
  \item<5-> \mintinline{racket}{(check-expect (launch -3 " ") -3)}
  \item<6-> \mintinline{racket}{(check-expect (launch 2 " ") 2)}
  \item<7-> There are more cases that we can consider, but this is enough
    for now.
  \item<8-> Similar to designing \mintinline{racket}{show}, our tests and
    used of an itemization tell us that we need a conditional expression.
  \end{itemize}
\end{frame}

\defverbatim[colored]\launchSkeleton{
\begin{minted}{racket}
    (define (launch x ke)
      (cond
        [(string? x) ...]
        [(<= -3 x -1) ...]
        [(>= x 0) ...]))
\end{minted}
}

\defverbatim[colored]\launchSimple{
\begin{minted}{racket}
    [(<= -3 x -1) x]
    [(>= x 0) x]
\end{minted}
}

\begin{frame}
  \frametitle{Launch! (cont.)}
  So, let's skeleton out our definition:
  \begin{itemize}
  \item<2-> \launchSkeleton
  \item<3-> Fleshing out the first condition based on the tests is simple:
  \item<4-> \mintinline{racket}{(if (string=? ke " ") -3 x)}
  \item<5-> The next two conditions are very simple:
    \launchSimple
  \item<6-> Filling in our skeleton with these three conditions,
    finishes the definition of \mintinline{racket}{launch}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Pretty Fly for a Program}
  The last function we need to define is our clock tick handling
  function \mintinline{racket}{fly}.
  \begin{itemize}
  \item<2-> You know the drill...
  \item<3-> \mintinline{racket}{(check-expect (fly "resting") "resting")}
  \item<4-> \mintinline{racket}{(check-expect (fly -3) -2)}
  \item<5-> \mintinline{racket}{(check-expect (fly -1) HEIGHT)}
  \item<6-> \mintinline{racket}{(check-expect (fly 5) (- 5 YDELTA))}
  \item<7-> So, resting rockets stay at rest, the count down
    moves to the next number unless the current number is -1, and rockets descend by 3 points at a time.
  \item<8-> Our only trouble lies in the transition function correct
    for when the world state is -1.
  \end{itemize}
\end{frame}

\defverbatim[colored]\flySkeleton{
\begin{minted}{racket}
    (define (fly x)
      (cond
        [(string? x) x]
        [(<= -3 x -1) ...]
        [(>= x 0) ...])
\end{minted}
}

\begin{frame}
  \frametitle{Pretty Fly for a Program (cont.)}
  You know the drill again...let's write the skeleton for
  \mintinline{racket}{fly}. For simplicity, we'll complete the
  first condition.
  \begin{itemize}
  \item<2-> \flySkeleton
  \item<3-> Completing the countdown update is a bit tricky:
  \item<4-> \mintinline{racket}{(if (= x -1) SCENE-HEIGHT (+ x 1))}
  \item<5-> Why did we need the condition and why do we set
    the state of the world to \mintinline{racket}{SCENE-HEIGHT}?
  \item<6-> Finally, we move the racket upwards with:
    \mintinline{racket}{(- x YDELTA)}
  \end{itemize}  
\end{frame}

\defverbatim[colored]\main{
\begin{minted}{racket}
  (define (main ws)
    (big-bang ws
      [to-draw show]
      [on-key launch]
      [on-tick fly]))
\end{minted}
}

\begin{frame}
  \frametitle{Elon Musking It}
  So let's put it all together and write the main function:
  \pause
  \main
  \pause
  Let's test it out!
  \pause
  What could have been improved about the code?
  \pause
  Even beyond that, using negative numbers for the countdown
  was an odd solution. We'll address this later.
\end{frame}

\begin{frame}
  \frametitle{Itemization Design}
  The introduction of itemizations necessitated that we alter
  our design recipes.
\end{frame}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
