%%% Local Variables:
%%% TeX-command-extra-options: "-shell-escape"
%%% mode: latex
%%% TeX-master: t
%%% End:
\documentclass{beamer}
\usepackage{caption}
\usepackage{minted}
\usepackage{tikz}
\usepackage{xcolor}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=1.5cm, minimum height=0.6cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=1.5cm, minimum height=0.5cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [circle, radius=2.5cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
\usepackage[labelformat=simple]{subcaption}

\usetheme{Singapore}
\title{Arbitrarily Large Data}
\begin{document}
\begin{frame}
\titlepage
\end{frame}
\section{Lists}

\begin{frame}
  \huge \emph{Recursion} - see recursion
\end{frame}

\begin{frame}
  \frametitle{Self Referentiality Powerful and Scary}
  \begin{figure}
    \begin{subfigure}{0.3\textwidth}
      \includegraphics[width=0.9\textwidth]{images/recursive-tree.JPG}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
      \includegraphics[width=0.9\textwidth]{images/liars-paradox.jpeg}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
      \includegraphics[width=0.9\textwidth]{images/reflections.jpg}
    \end{subfigure}
  \end{figure}
\end{frame}

\begin{frame}
  \frametitle{Self Referentiality}
  The ability to self reference is \emph{powerful} but also \emph{troublesome}.
  \begin{itemize}
  \item<2-> Through self referentiality, we can construct the most basic mathematical tool that has
    been proven to be a powerful concept throughout history--the natural numbers.
  \item<3-> This leads to many other powerful structures like other numbers, lists, trees, etc.
  \item<4-> But we also got the first instances of extremely troublesome concepts--paradoxes.
  \item<5-> The omnipotence paradox - asked if it was possible for a being to exist so powerful that it could create a stone that it could not lift.
  \item<6-> The Epimenides paradox, 'All Cretans are liars' when uttered by an ancient Greek Cretan was one of the first recorded versions. 
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Stacking Dolls and Us}
  \begin{center}
    \includegraphics[width=0.5\textwidth]{images/matryoshka.jpg}
  \end{center}
  Hello me, meet the previous me.\\
  -Dave Mustaine\\
  --Me
\end{frame}

\begin{frame}
  \frametitle{Self Referential Data and Racket}
  So far, we have only written programs with fixed size data (well numbers and strings aren't truly fixed size but they are primitive).
  \begin{itemize}
  \item<2-> We don't currently have a way to specify data definitions for extensible data.
  \item<3-> Consequently, we can't support the creation of programs like a space invaders game with
    flexible numbers of enemies.
  \item<4-> So we will change how we specify data definitions to support things like this and will revise our design recipes
    for dealing with extensible data
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Lists: A Fundamental Structure }
  One of the most important things to get used to in functional programming is dealing with lists.
  \begin{itemize}
  \item<2-> Lists are quite common in programming in general as a way to store related data for processing data.
  \item<3-> A large part of the execution time of many programs is spent iterating over lists.
  \item<4-> The simplest list we can specify is the empty list \mintinline{racket}{'()}
  \item<5-> We can start building lists with \mintinline{racket}{cons}--for example
    \mintinline{racket}{(cons 1 '())} $\hookrightarrow$ \mintinline{racket}{'(1)}.
  \item<6-> We can also use other types like strings in our lists \mintinline{racket}{(cons "Mercury" '())}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Analyzing Cons Cells}
  Let's consider the following list: \mintinline{racket}{(cons "Mercury" '())}.
  \begin{itemize}
  \item<2-> We have the following visual representation of this list:
    \includegraphics[width=0.2\textwidth]{images/mercury-cons.png}
  \item<3-> For \mintinline{racket}{(cons "Earth" (cons "Venus" (cons "Mercury" '()))))}
    we have the following visual representation:
    \includegraphics[width=0.35\textwidth]{images/planet-cons.png}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Cons Cell Properties}
  The nested representation of cons cells gets complicated as lists get larger, very quickly.
  \begin{itemize}
  \item<2-> Programmers usually opt to think about them in terms of box and pointer diagrams instead:
    \includegraphics[width=0.5\textwidth]{images/box-pointer-back.png}
  \item<3-> It's more natural to think about this in a more forward manner however, where the box on the
    left corresponds to the \emph{head} of the list and there is a pointer to the \emph{tail} of the list:
    \includegraphics[width=0.5\textwidth]{images/box-pointer-forward.png}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Some Weird Lists}
  By this point, you may be used to thinking about lists as \emph{homogeneous} collections of items.
  \begin{itemize}
  \item<2-> But you can also creates lists from elements of different types:
    \mintinline{racket}{(cons "Peter" (cons 26 (cons \#t '())))}
  \item<3-> In this list we have a string, an integer, and a boolean value.
  \item<4-> We can also think about adding structs or functions to our list.
  \item<5-> Alternatively, instead of thinking about our list as being unstructured,
    we could say that is a list whose values are an itemization of strings, integers, and true.
  \item<6-> If we cons on a new value with a type not present in the itemization, then we could define
    an itemization that extends our previous one.
  \item<7-> And building on my previous lectures, we can even think of this list as representing
    something like a person. But in that case we should define a struct!
  \end{itemize}
\end{frame}

\defverbatim[colored]\ThreeList{
\begin{minted}[fontsize=\footnotesize]{racket}
    ; A 3LON is a list of three numbers: 
    ;   (cons Number (cons Number (cons Number '())))
    ; interpretation a point in 3-dimensional space 
\end{minted}
}

\begin{frame}
  \frametitle{Data Definitions and Lists}
  Consider the following list: \mintinline{racket}{(cons 1 (cons 2 (cons 3 '())))}
  \begin{itemize}
  \item<2-> What kind of data definition could we given for this list?
  \item<3-> \ThreeList
  \item<4-> Again, such a data definition seems more appropriate for struct.
  \item<5-> More importantly, the list is extensible and this definition
    doesn't address the fact that consing an additional element to
    the aforementioned list creates a value outside of this definition.
  \item<6-> So how do we talk about data definitions
    where we can construct values of arbitrarily large size?
  \end{itemize}
\end{frame}

\defverbatim[colored]\ListOfNames{
\begin{minted}[fontsize=\footnotesize]{racket}
    ; A List-of-names is one of: 
    ; – '()
    ; – (cons String List-of-names)
    ; interpretation a list of guests, by last name
\end{minted}
}

\begin{frame}
  \frametitle{Lists are Recursively Defined}
  Let's say that we are designing a program for hotel booking for a large
  hotel. For a given weekend we need a list of dynamic size for our
  guest list.
  \begin{itemize}
  \item<2-> Assuming we only store the guest's last name, how do we shape
    our data definition to meet this dynamic size requirement?
  \item<3-> \ListOfNames
  \item<4-> Such a definition should seem familiar to you at this point.
  \item<5-> When programming data structures in Java, you should have
    become used to recursive instances of a class in a class definition.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{List-of-names Examples}
  What are some example values of our List-of-names definition?
  \begin{itemize}
  \item<2-> Starting with the first clause of our definition's itemization,
    we have a nice atomic element.
  \item<3-> This element is the empty list \mintinline{racket}{'()} and forms the smallest  value in our list.
  \item<4-> The most simple elements of \emph{inductively} defined data are known
    as our base values, in correspondance with the \emph{base case} of an
    inductive proof.
  \item<5-> Don't worry about this too much for now, let's look
    at more values of our data definition.
  \item<6-> In order to construct a more complicated list, we look at the second clause of our itemization. We must cons a string
    onto another list, but so far we only know how to constuct the empty list.
  \item<7-> This allows us to define a single element list like:
    \mintinline{racket}{(cons "Nadal" '())}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{List-of-names Examples (cont.)}
  How do we create a two element guest list?
  \begin{itemize}
  \item<2-> Easy, we apply the second case of our itemization again and cons something onto a one element list!
  \item<3-> \mintinline{racket}{(cons "Federer" (cons "Nadal" '()))}
  \item<4-> And of course, we can inductively keep constructing an arbitrary
    list of size N+1 from a list of size N.
  \item<5-> This brings an interesting point up. Can I use induction to prove
    things about propositions that are generated from things besides natural numbers?
  \item<6-> Yes, inductively defined types come with their own induction principles. Programming language theorists do induction over different structures often.
  \item<7-> But back to programming land! We seemed to brush over some details.
    What exactly are \mintinline{racket}{'()} and \mintinline{racket}{cons}?
  \end{itemize}
\end{frame}

\section{Atoms and Constructors}
\begin{frame}
  \frametitle{Empty Lists and Cons}
  So, we've mentioned that \mintinline{racket}{'()} is a value, but what
  is special about it?
  \begin{itemize}
  \item<2-> Well, like numbers, booleans, and strings it is a new kind of \emph{atomic} value in our language.
    Struct values, the last new value form we introduced are compound values--i.e. they are composed
    of many other values.
  \item<3-> It is a unique value in that there is a built-in predicate to recognize it, \mintinline{racket}{empty?}
  \item<4-> \mintinline{racket}{(empty? '())} returns true and \mintinline{racket}{(empty? v)} returns false for any other
    value, v.
  \item<5-> And of course, we can start building lists containing elements by using \mintinline{racket}{cons} with it.
  \item<6-> So, what's the deal with \mintinline{racket}{cons}?
  \item<7-> Recall, when we defined a struct, how did we create new values for a struct type?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Dissecting Cons}
  So, let's assume that we can define a struct for \mintinline{racket}{cons} as follows:
  \begin{itemize}
  \item<2-> \mintinline{racket}{(struct cons [first rest])}
  \item<3-> \mintinline{racket}{(cons 1 '())} seems to work as expected.
  \item<4-> We can also use a value that isn't a list as the ``rest'': \mintinline{racket}{(cons 1 2)}.
  \item<5-> For simplicity in the book, they don't allow this because they want you to think of cons cells as \emph{lists}.
  \item<6-> But in reality, a list is a series of cons pairs whose final ``rest'' is \mintinline{racket}{'()}.
  \item<7-> So, I recommend mostly using \mintinline{racket}{cons} for constructing lists, but you can also construct pairs.
  \item<8-> If you need to specify a larger list quickly, use
    something like \mintinline{racket}{'(1 2 3)} or \mintinline{racket}{(list 1 2 3)} instead of \mintinline{racket}{(cons 1 (cons 2 (cons 3 '())))}
  
  \end{itemize}
\end{frame}

\defverbatim[colored]\ContainsHeader{
\begin{minted}{racket}
    ; List-of-names -> Boolean
    ; determines whether "Smith" is in a-list-of-names
    (define (contains-smith? a-list-of-names)
      \#f)
\end{minted}
}

\begin{frame}
  \frametitle{List Programs}
  We can get the first element of a list with \mintinline{racket}{first} and the
  rest of the list with \mintinline{racket}{list}.
  \begin{itemize}
  \item<2-> With this, we can now start to write programs using lists.
  \item<3-> \textbf{Sample Problem} - You're the most popular person in town. You have lots of friends. So many in fact that you can't remember all of your friends' names. Assume that your friends are stored in a list. Write a program to check that you have a friend named ``Smith''.
  \item<4-> \ContainsHeader
  \item<5-> Ok, so now we need functional examples.
  \item<6-> What should \mintinline{racket}{(contains-smith? '())} return?
  \item<7-> It should return \#f of course!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recurring in the Lists}
  Ok, so we know that searching for Smith in the empty list returns false.
  \begin{itemize}
  \item<2-> What should \mintinline{racket}{(contains-smith? (cons "Trufant" '()))} return?
  \item<3-> It should return \#f since ``Trufant'' isn't ``Smith'' and
    the empty list doesn't contain any strings.
  \item<4-> What should \mintinline{racket}{(contains-smith? (cons "Smith" '()))} return?
  \item<5-> It should return \#t of course!
  \item<6-> What should \mintinline{racket}{(contains-smith? (cons "Junpei" (cons "Smith" '())))} return?
  \item<7-> Still \#t!
  \item<8-> What about \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? (cons "Junpei" (cons "Smith" (cons "Trufant" '()))))}?
  \end{itemize}
\end{frame}

\defverbatim[colored]\ContainsSkeleton{
\begin{minted}[fontsize=\footnotesize]{racket}
    ; List-of-names -> Boolean
    ; determines whether "Smith" is in a-list-of-names
    (define (contains-smith? a-list-of-names)
      (cond
         [(empty? a-list-of-names) ...]
         [(cons? a-list-of-names) ...]))
\end{minted}
}

\begin{frame}
  \frametitle{Recurring in the Lists}
  Ok, so let's come up with one last general example.
  \begin{itemize}
  \item<2-> What about \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? (cons "Junpei" (cons "Trufant" '())))}?
  \item<3-> This returns \#f.
  \item<4-> Ok, so now I have some functional examples and can create tests from them.
  \item<5-> Turning to step 4 of our design process, how I start writing a
    skeleton? Recall that we are taking an itemization as input.
  \item<6-> \ContainsSkeleton
  \item<7-> Ok, so this part was not so bad. But now we have to start coding
    for one of those conditions. Which is easier to start with?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recurring in the Lists}
  \textbf{Always start with handling the empty list!}
  \begin{itemize}
  \item<2-> Why?
  \item<3-> It is the base case, and almost every recursion will hit
    this in order to return some value from the function. This is necessary
    for recursion to terminate.
  \item<4-> So, based on our functional examples, what should the return value
    be when we hit the empty list?
  \item<5-> That's right, it should be false!
  \item<6-> Now how do we start finishing the skeleton for the case when
    we have a cons cell?
  \item<7-> Well each cons cell is a string being stacked onto another list. Shouldn't we check whether that string is ``Smith''?
  \end{itemize}
\end{frame}

\defverbatim[colored]\CheckSmith{
\begin{minted}[fontsize=\footnotesize]{racket}
    ; List-of-names -> Boolean
    ; determines whether "Smith" is in a-list-of-names
    (define (contains-smith? a-list-of-names)
      (cond
         [(empty? a-list-of-names) \#f]
         [(cons? a-list-of-names) 
             ... (string=? "Smith" (first a-list-of-names)) ...]))
\end{minted}
}

\begin{frame}
  \frametitle{Recurring in the Lists}
  Let's write some code to check the outermost cons cell.
  \begin{itemize}
  \item<2-> \CheckSmith
  \item<3-> Assume a-list-of-names is \mintinline{racket}{'("Smith" "Trufant")}
  \item<4-> What does \mintinline{racket}{(string=? "Smith" (first a-list-of-names))} return?
  \item<5-> it returns \#t
  \item<6-> But what if a-list-of-names is \mintinline{racket}{'("Junpei" "Smith" "Trufant")}
  \item<7-> It returns \#f
  \end{itemize}
\end{frame}

\defverbatim[colored]\SearchRest{
\begin{minted}[fontsize=\footnotesize]{racket}
    ... (string=? "Smith" (first a-list-of-names)) 
      ... (contains-smith? (rest a-list-of-names)) ...
\end{minted}
}

\begin{frame}
  \frametitle{Recurring in the Lists}
  This latter case is very important. What do we need to if the current head of the list  isn't ``Smith''?
  \begin{itemize}
  \item<2-> We must search the rest of the list of course.
  \item<3-> How do we search the rest of the list?
  \item<4-> \textbf{With a recursive call on the rest of the list!}
  \item<5-> So, let's update our skeleton to:
    \SearchRest
  \item<6-> \includegraphics[width=0.4\textwidth]{images/dory.jpg}
    Err well recursing, rather...
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recurring in the Lists}
  So what is \mintinline{racket}{(rest '("Junpei" "Smith" "Trufant"))}?
  \begin{itemize}
  \item<2-> It's \mintinline{racket}{'("Smith" "Trufant")}
  \item<3-> So, now in the recursive call, a-list-of-names is:
    \mintinline{racket}{'("Smith" "Trufant")}
  \item<4-> Is this empty?
  \item<5-> No, it's a cons cell.
  \item<6-> What is \mintinline{racket}{(first a-list-of-names)}?
  \item<7-> "Smith"
  \item<8-> So, what does: \mintinline{racket}{(string=? "Smith" (first a-list-of-names))} return?
  \item<9-> \#t
  \item<10-> But what happens when we return from this recursive call?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recurring in the Lists}
  We were previously in a state where the head of the list wasn't "Smith".
  \begin{itemize}
  \item<2-> So, how do we put together that we had \#f from checking
    that the head of the list wasn't "Smith", with finding "Smith" in the recursive call (which returned \#t)?
  \item<3-> Think about how you would write the program
    with a loop in Java or Python first.
  \item<4-> Our friend \mintinline{racket}{or} comes to the rescue.
  \item<5-> Recall that the evaluation of \mintinline{racket}{(or bool-1 bool-2)}
    does not need to evaluate bool-2 if bool-1 is \#t, but does when bool-1 is \#f
  \item<6-> Recall that we \textbf{only} need to search the rest of the list
    when the head is not "Smith"
  \item<7-> Finally, if we search the entire list and do not find "Smith" (i.e. we hit the empty list), we return \#f.
  \item<8-> So, how do we finish our code?
  \end{itemize}
\end{frame}

\defverbatim[colored]\CheckSmithFinal{
\begin{minted}[fontsize=\footnotesize]{racket}
    ;; List-of-names -> Boolean
    ;; determines whether "Smith" is in a-list-of-names
    (define (contains-smith? a-list-of-names)
      (cond
         [(empty? a-list-of-names) \#f]
         [(cons? a-list-of-names) 
             (or (string=? "Smith" (first a-list-of-names)) 
                 (contains-smith? (rest a-list-of-names)))]))
\end{minted}
}

\begin{frame}
  \frametitle{Recurring in the Lists}
  The final version of our function looks like the following:
  \CheckSmithFinal

  \begin{itemize}
  \item<2-> Let me walk through how the recursion works on this code now.
  \item<3-> We start with a call: \mintinline{racket}{(contains-smith? '("Junpei" "Smith" "Trufant"))}
  \item<4-> Now we can replace the parameter \mintinline{racket}{alist-of-names} with \mintinline{racket}{'("Junpei" "Smith" "Trufant")}  
  \end{itemize}
\end{frame}

\defverbatim[colored]\CheckSmithSubOne{
\begin{minted}[fontsize=\footnotesize]{racket}
(cond
   [(empty? '("Junpei" "Smith" "Trufant")) \#f]
   [(cons? '("Junpei" "Smith" "Trufant")) 
       (or (string=? "Smith" (first '("Junpei" "Smith" "Trufant"))) 
           (contains-smith? (rest '("Junpei" "Smith" "Trufant"))))])
\end{minted}
}

\defverbatim[colored]\ContainsElse{
\begin{minted}[fontsize=\footnotesize]{racket}
    (or (string=? "Smith" (first '("Junpei" "Smith" "Trufant"))) 
        (contains-smith? (rest '("Junpei" "Smith" "Trufant"))))
\end{minted}
}


\begin{frame}
  \frametitle{Recurring in the Lists}
  We now have the following code after this replacement:
  \CheckSmithSubOne

  \begin{itemize}
  \item<2-> What does \mintinline{racket}{(empty? '("Junpei" "Smith" "Trufant"))} return?
  \item<3-> \#f
  \item<4-> So, we go to the next cond branch to check the condition. What does \mintinline{racket}{(cons? '("Junpei" "Smith" "Trufant"))} return?
  \item<5-> \#t
  \item<6-> So, we need to evaluate:
    \ContainsElse
    
  \end{itemize}
\end{frame}

\defverbatim[colored]\ContainsElseEvalOne{
\begin{minted}[fontsize=\footnotesize]{racket}
        (or \#f
            (contains-smith? (rest '("Junpei" "Smith" "Trufant"))))
\end{minted}
}

\begin{frame}
  \frametitle{Recurring in the Lists}
  How do we start evaluating an or-expression?
  \begin{itemize}
  \item<2-> We start with the first expression to check in the or:
   \mintinline[fontsize=\footnotesize]{racket}{(string=? "Smith" (first '("Junpei" "Smith" "Trufant"))}
  \item<4-> What does \mintinline[fontsize=\footnotesize]{racket}{(first '("Junpei" "Smith" "Trufant")} return?
  \item<5-> "Junpei"
  \item<6-> What does \mintinline[fontsize=\footnotesize]{racket}{(string=? "Smith" "Junpei")} evaluate to?
  \item<7-> \#f
  \item<8-> So, how do we evaluate:
    \ContainsElseEvalOne 
  \item<9-> We must check if the following evaluates to \#t: \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? (rest '("Junpei" "Smith" "Trufant")))}
  \end{itemize}
\end{frame}

\defverbatim[colored]\CheckSmithSubTwo{
\begin{minted}[fontsize=\footnotesize]{racket}
    (cond
       [(empty? '("Smith" "Trufant")) \#f]
       [(cons? '("Smith" "Trufant")) 
           (or (string=? "Smith" (first '("Smith" "Trufant"))) 
               (contains-smith? (rest '("Smith" "Trufant"))))])
\end{minted}
}

\begin{frame}
  \frametitle{Recurring in the Lists}
  How do we evaluate:
  \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? (rest '("Junpei" "Smith" "Trufant")))}?
  \begin{itemize}
  \item<2-> We first evaluate: \mintinline[fontsize=\footnotesize]{racket}{(rest '("Junpei" "Smith" "Trufant"))}
  \item<3-> This returns \mintinline[fontsize=\footnotesize]{racket}{'("Smith" "Trufant")}
  \item<4-> Now, how do we evaluate:
    \mintinline[fontsize=\footnotesize]{racket}{(contains-smith?  '("Smith" "Trufant"))}?
  \item<5-> We must replace \mintinline[fontsize=\footnotesize]{racket}{a-list-of-names} in the body of the function with \mintinline[fontsize=\footnotesize]{racket}{'("Smith" "Trufant")}.
  \item<6-> This leads to the following code:
    \CheckSmithSubTwo
  \end{itemize}
\end{frame}

\defverbatim[colored]\ContainsElseRecur{
\begin{minted}[fontsize=\footnotesize]{racket}
        (or (string=? "Smith" (first '("Smith" "Trufant"))) 
            (contains-smith? (rest '("Smith" "Trufant"))))
\end{minted}
}

\begin{frame}
  \frametitle{Recurring in the Lists}
  Let's start by evaluating the first branch of the cond.
  \begin{itemize}
  \item<2-> What does \mintinline[fontsize=\footnotesize]{racket}{(empty? '("Smith" "Trufant"))} return?
  \item<3-> \#f
  \item<4-> What does \mintinline[fontsize=\footnotesize]{racket}{(cons? '("Smith" "Trufant"))}
  \item<5-> \#t
  \item<6-> We need to evaluate:
    \ContainsElseRecur
  \item<7-> What does \mintinline[fontsize=\footnotesize]{racket}{(first '("Smith" "Trufant"))} return?
  \item<8-> "Smith"
  \item<9-> So, what does \mintinline[fontsize=\footnotesize]{racket}{(string=? "Smith" "Smith")} return?
  \item<10-> \#t
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recurring in the Lists}
  So, how does: \mintinline[fontsize=\footnotesize]{racket}{(or \#t (contains-smith? (rest '("Smith" "Trufant"))))} evaluate?
  \begin{itemize}
  \item<2-> Namely, do I need to evaluate: \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? (rest '("Smith" "Trufant")))}?
  \item<3-> No, because or can short circuit and return \#t as soon
    as it sees a single \#t
  \item<4-> So, \mintinline[fontsize=\footnotesize]{racket}{(or \#t (contains-smith? (rest '("Smith" "Trufant"))))} evaluates to
    \#t without recursing anymore.
  \item<5-> So, the result of this expression is \#t.
  \item<6-> But how did we get here?
  \item<7-> We got here by replacing \mintinline{racket}{a-list-of-names} with \mintinline[fontsize=\footnotesize]{racket}{'("Smith" "Trufant")}.
  \item<8-> But why did we do that?
  \item<9-> Because we called:
    \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? (rest '("Smith" "Trufant"))}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recurring in the Lists}
  In what context did we call \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? (rest '("Smith" "Trufant"))}?
  \begin{itemize}
  \item<2-> It was called in:
    \ContainsElseEvalOne
  \item<3-> Ok, so now we know the return value of the recursive
    call and have:
    \mintinline[fontsize=\footnotesize]{racket}{(or \#f \#t)}
  \item<4-> This returns \#t:
  \item<5-> This means that the overall result of:
    \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? '("Junpei" "Smith" "Trufant"))} is \#t.
  \item<6-> 
    \includegraphics[width=0.25\textwidth]{images/relief.jpg}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recurring in the Lists}
  So, what would happen if we instead called:
  \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? '("Junpei" "Smith" "Trufant"))}?
  \begin{itemize}
  \item<2-> The basic intuition is that we have an extra recursive call. I'll draw a simplified evaluation on the board.
  \item<3-> But what about: \mintinline[fontsize=\footnotesize]{racket}{(contains-smith? '("Junpei" "Trufant"))}?
  \item<4-> The inuition is that we hit the empty list and return \#f. A \#t is never produced. I'll draw a simplified evaluation.
  \item<5-> How do I write a more general function called
    \mintinline{racket}{contains?} where \mintinline[fontsize=\footnotesize]{racket}{(contains? 1 '("Smith" 1 \#f))} returns \#t
  \item<6-> Let me pull up Dr. Racket and we can design it live.
  \item<7-> A useful built-in function is \mintinline{racket}{member}, which
    essentially works like \mintinline[fontsize=\footnotesize]{racket}{(contains?}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Designing with Self Referential Data}
  As usual, new forms of data change our design process.
  \begin{itemize}
  \item<2-> (1) If a problem statement is about information of arbitrary size, you need a self-referential data definition to represent it. For a self-referential data definition to be valid, it must satisfy two conditions.
    \begin{enumerate}
    \item<3-> It must contain at least two clauses.
    \item<4-> At least one of the clauses must not refer back to the class of data that is being defined (and refers to other well-defined data).
    \end{enumerate}
  \item<5-> (1) You must check the validity of self-referential data definitions with the creation of data examples. Start with the clause that does not refer to the data definition; continue with the other one, using the first example where the clause refers to the definition itself.  With name lists, you would \mintinline{racket}{'()} and
    \mintinline{racket}{(cons "a" '())}.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Designing with Self Referential Data (cont.)}
  If it is impossible to design data examples in step (1), your definition probably needs to be reworked.
  \begin{itemize}
  \item<2-> (2) Nothing changes here, since we want a general description of how the function works without technical details. Obviously, self referential data can now appear in signatures
  \item<3-> (3) When it comes to functional examples, be sure to work through inputs that use the self-referential clause of the data definition several times. The non self-referential clauses should also be used. This is the best way to formulate tests that cover the entire function definition later. For lists of strings, you want examples involving things like \mintinline{racket}{'()}, \mintinline{racket}{(cons "a" '())}, \mintinline{racket}{'("b" "a")} etc. 
  \end{itemize}
\end{frame}

\defverbatim[colored]\naturalRecursion{
\begin{minted}[fontsize=\footnotesize]{racket}
(define (fun-for-los alos)
  (cond
    [(empty? alos) ...]
    [else
      (... (first alos) ...
       ... (fun-for-los (rest alos)) ...)]))
\end{minted}
}

\begin{frame}
  \frametitle{Designing with Self Referential Data (cont.)}
  (4) Overall, self referential data looks similar to our previous work with itemizations and mixed data. We can think about it with the
  following table:
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/template-development.png}
  \end{center}
\end{frame}



\begin{frame}
  \frametitle{Designing with Self Referential Data (cont.)}
  (4) In order to start skeletoning out some function, we must put a cond clause per each part of our data definition. In the areas where a cond deals with a self referential clause, we must put a recursive call, for the corresponding cond clause.
  \begin{itemize}
  \item<2-> \naturalRecursion.
  \item<3-> This is known as the natural recursion over these kinds of data (as upposed to \emph{unnatural} recursion).
  \item<4-> (5) When programming our function we also start with the cases for data clauses that don't contain self reference.
  \item<5-> (5) After this, we move on to self referential clauses by assuming that our recursive call works and designing the rest of our code based on that assumption.
  \item<6-> (5) Why is this assumption valid?
  \item<7-> (5) Proof by induction!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Designing with Self Referential Data (cont.)}
  (5) Finishing the code for recursive calls can be tricky. Try using the following approaches:
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/finish-recursion.png}

  \end{center}
  Often our combinators are things like +, and, cons etc.
\end{frame}
 
\begin{frame}
  \frametitle{Designing with Self Referential Data (cont.)}
  (5) If an existing combinator does not work, and you're not clear how to proceed then use the tabular method:
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/table-method.png}
  \end{center}
   
\end{frame}

\begin{frame}
  \frametitle{Designing with Self Referential Data (cont.)}
  (5) When designing your table, start small and work outwards to larger examples
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/table-example.png}
  \end{center}
   
\end{frame}

\begin{frame}
  \frametitle{Designing with Self Referential Data (cont.)}
  (6) There are a couple of changes to testing.
  \begin{itemize}
  \item<2-> First, make sure that the function that combines the result of a recursive call works.
  \item<3-> If you use the tabular method, convert such examples into tests. 
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Designing with Self Referential Data (cont.)}
  Here's an overview of how our design  process works for self referential data.
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/self-design.png}
  \end{center}
\end{frame}

\defverbatim[colored]\ALoA{
\begin{minted}{racket}
;; A List-of-amounts is one of: 
;; – '()
;; – (cons PositiveNumber List-of-amounts)
\end{minted}
}

\begin{frame}
  \frametitle{Summing Lists}
  Consider the following data definition:
  \ALoA
  \begin{itemize}
  \item<2-> How do we write a function that sums a list of amounts?
  \item<3-> Let's start our design process. To finish step 1 of
    our data interpretation, we need some examples.
  \item<4-> \mintinline{racket}{'()} is always a good example
  \item<5-> Now for data of size one, we might want
    \mintinline{racket}{(cons 1 '())}
  \item<6-> For data of size two, we might want
    \mintinline{racket}{(cons 7 (cons 1 '()))}
  \item<7-> Let's turn to step 2 of our design process now.
  \end{itemize}
\end{frame}

\defverbatim[colored]\SumHeader{
\begin{minted}{racket}
    ;; A-list-of-amounts -> PositiveNumber
    ;; Simply sums a collection of positive numbers
    (define (sum list-a) 0)
\end{minted}
}

\defverbatim[colored]\SumTests{
\begin{minted}{racket}
    (check-expect (sum '()) 0)
    (check-expect (sum '(1)) 1)
    (check-expect (sum '(7 1)) 8)
\end{minted}
}

\defverbatim[colored]\SumSkeleton{
\begin{minted}[fontsize=\footnotesize]{racket}
    (define (sum list-a)
      (cond
        [(empty? list-a) ...]
        [(cons? list-a) 
          ... (first list-a) ... (sum (rest list-a)) ...]))
\end{minted}
}

\begin{frame}
  \frametitle{Summing Lists}
  Let's start by providing our signature and statement of purpose:
  \begin{itemize}
  \item<2-> \SumHeader
  \item<3-> We can now use our data examples to formulate tests
    as functional examples.
  \item<4-> \SumTests
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Summing Lists}
  Let's turn to providing our skeleton for sum.
  \begin{itemize}
  \item<2-> \SumSkeleton
  \item<3-> Notice that we have a natrual recursion here, where
    sum is called on the rest of the list.
  \item<4-> Let us assume inductively that this call correctly sums
    the rest of the list.
  \item<5-> How do we design our combinator for combining this sum
    with the first element of the list?
  \item<6-> We simply add the first element of the list to the sum
    of the sublist!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Summing Lists}
  Let's use concrete examples to illustrate this.
  \begin{itemize}
  \item<2-> Assume \mintinline{racket}{(sum '())} works. What should
    its value be?
  \item<3-> 0! So now if we have the case where we are considiering
    \mintinline{racket}{(cons 1 '())} we assume that the recursive
    call to \mintinline{racket}{(sum '())} works.
  \item<4-> Now let's add 1 to it. We get
    \mintinline{racket}{(+ 1 (sum '()))} where we know that
    the recursive sum returns 0. So the result is 1.
  \item<5-> Now we can consider our biggest data example:
    \mintinline{racket}{(cons 7 (cons 1 '()))}
  \item<6-> We know that \mintinline{racket}{(sum (cons 1 '())}
    returns 1. So,  \mintinline{racket}{(+ 7 (sum (cons 1 '()))}
    returns 8. Intuitively, this result is correct.
  \item<7-> So, how do we go from the specific cases to the general? Note that 1 and 7 were the heads of the sublists at some point in the recursion. 
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Summing Lists}
  What do we use to get the head of the list?
  \begin{itemize}
  \item<2-> \mintinline{racket}{(first list-a)}
  \item<3-> How did we sum the sublist?
  \item<4-> \mintinline{racket}{(sum (rest list-a))}
  \item<5-> So, how do we add the running sum to the list head?
  \item<6->  \mintinline{racket}{(+ (first list-a) (sum (rest list-a)))}
  \item<7-> Why is this correct?
  \item<8-> Because we inductively assume that the recursion over
    the sublist is correct. (And our examples verified this!)
  \item<9-> So, let me walk through this intuition by hand.
  \end{itemize}
\end{frame}

\defverbatim[colored]\SumFinal{
\begin{minted}[fontsize=\footnotesize]{racket}
;;A-list-of-amounts -> PositiveNumber
(define (sum list-a)
  (cond
    [(empty? list-a) 0]
    [(cons? list-a) 
      (+ (first list-a) (sum (rest list-a)))]))
\end{minted}
}

\begin{frame}
  \frametitle{Summing Lists}
  Here is the final version of the function:
  \SumFinal
  \begin{itemize}
  \item<2-> Now, we should go through and run our tests.
  \item<3-> In general, we can write similar functions by
    producing the skeleton and thinking of the correct combinator
    for combining the head of the list to the result of recursing
    over the tail of the list.
  \item<4-> But what happens if we needed to do computation after
    the recursion ends?
  \end{itemize}
\end{frame}

\defverbatim[colored]\average{
\begin{minted}[fontsize=\footnotesize]{racket}
    ;;A-list-of-amounts -> PositiveNumber
    (define (average list-a)
      (/ (sum list-a) (length list-a)))
\end{minted}
}

\begin{frame}
  \frametitle{Averaging Lists}
  So, we have a nice function to sum lists. How would I got about
  taking the average of a list?
  \begin{itemize}
  \item<2-> How is a sum related to an average?
  \item<3-> Well an average is a sum divided by a count.
  \item<4-> How do we count the number of elements in a list?
  \item<5-> With \mintinline{racket}{length} of course!
  \item<6-> So, what does our average function look like?
  \item<7-> \average
  \item<8-> But what happens if we call:
    \mintinline{racket}{(average '())}?
  \end{itemize}
\end{frame}

\defverbatim[colored]\NonEmpty{
\begin{minted}[fontsize=\footnotesize]{racket}
    ;; NE-list-amounts is one of
    ;; (cons PositiveNumber '())
    ;; (cons PositiveNumber NE-list-amounts
    (define NE-EX1 (cons 2 '()))
\end{minted}
}

\defverbatim[colored]\averageNE{
\begin{minted}[fontsize=\footnotesize]{racket}
    ;;NE-list-amounts -> PositiveNumber
    (define (average list-a)
      (/ (sum list-a) (length list-a)))
\end{minted}
}

\begin{frame}
  \frametitle{Averaging Lists}
  Uh oh! We have designed a partial function.
  \begin{itemize}
  \item<2-> There are two ways to rectify this.
    \begin{enumerate}
    \item<3-> We add an explicit check and give a meaningful
      error message
    \item<4-> We change the data interpretation and signature so that our function explicitly
      says that it expects non-empty lists.
    \end{enumerate}
  \item<5-> Let's consider option 2 where we reformulate our
    data interpretation and expect only input data that conforms to the signature.
  \item<6-> \NonEmpty
  \item<7-> \averageNE  
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Averaging Lists}
  Wait, sum expected values of a A-list-of-amounts
  and we provided a value from NE-list-amounts. Is this valid?
  \begin{itemize}
  \item<2-> Think about subtyping in Java.
  \item<3-> What does it mean for code to \emph{inherit} other code?
  \item<4-> Notice that all values of NE-list-amounts are values
    of A-list-of-amounts too.
  \item<5-> So there's a nice subset relationship here.
  \item<6-> The subtyping relationship we usually think of
    in terms of inheritance can't describe this relationship though.
    This is more of an instance of a \emph{type refinement}
  \item<7-> The moral of the story is that indeed because non-empty
    lists are a strict subset of empty and non-empty lists, there
    is not problem with the interaction of signatures.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Natural Numbers}
  We have talked about functions that consume and produce lists.
  \begin{itemize}
  \item<2-> one function that produces lists is \mintinline{racket}{make-list} which takes in a natural number n and an object and produces a list of length n which contains n copies of the given object.
  \item<3-> For example, \mintinline{racket}{(make-list 4 "weewoo")} produces  \mintinline{racket}{'("weewoo" "weewoo" "weewoo" "weewoo")}
  \item<4-> \includegraphics[width=0.4\textwidth]{images/weewoo.jpg}
  \item<5-> Okay, so I've previously spoiled this, but even though we
    think of numbers as atomic data, natural numbers are really an
    instance of arbitrarily sized data.
  \end{itemize}
\end{frame}

\begin{minted}{racket}

\end{minted}

\defverbatim[colored]\natDef{
\begin{minted}{racket}
    ;; a Nat is one of:
    ;; 0
    ;; (add1 Nat)
\end{minted}
}

\begin{frame}
  \frametitle{Natural Numbers}
  Well we obviously know that numbers can grow arbitrarily large.
  \begin{itemize}
  \item<2-> Previously, we've been able to specify lists of arbitrary size.
  \item<3-> How do we do something similar for numbers?
  \item<4-> Well, in a certain sense, we can think of numbers like
    lists where the underlying element didn't matter.
  \item<5-> So, for a number n, we can think of the next number
    as consing on nothing to this number \mintinline{racket}{(cons _ n)}.
  \item<6-> To actually finish providing a data definition,
    we propose the following:
    \natDef
  \item<7-> Notice that unlike lists, our atomic element is not
    the empty list but instead 0.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Natural Numbers}
  Also, instead of having an explict element to add to our data, we simply add another wrapper that acts as a way to \emph{count}
  \begin{itemize}
  \item<2-> This means that the number one is represented as well...
    \emph{one} wrapper around zero...
  \item<3-> But this is just the basic idea of \emph{tallying}
  \item<4-> But anyways, 1 is \mintinline{racket}{(add1 0)},
    2 is \mintinline{racket}{(add1 (add1 0))}, etc.
  \item<5-> Along these lines, \mintinline{racket}{add1} is a constructor, like
    \mintinline{racket}{cons} and \mintinline{racket}{sub1} is a selector like \mintinline{racket}{first} or \mintinline{racket}{rest}.
  \item<6-> Before with lists we used \mintinline{racket}{empty?} and \mintinline{racket}{cons?} to check for empty and non-empty lists.
  \item<7-> The corresponding predicates for numbers become: \mintinline{racket}{zero?} and \mintinline{racket}{positive?}.
  \end{itemize}
\end{frame}

\defverbatim[colored]\copierHeader{
\begin{minted}[fontsize=\footnotesize]{racket}
    ;; N T -> List<T>
    ;; Copies an element of type T, n times, to form
    ;; a list
    (define (copier n item) '())
\end{minted}
}

\begin{frame}
  \frametitle{Functions of Natural Numbers}
  Let's consider designing functions whose input is natural numbers?
  \begin{itemize}
  \item<2-> What happens if we want to make a function like \mintinline{racket}{make-list} that makes n copies of a given item.
  \item<3-> Why, we will need a recursive function over subnumbers.
  \item<4-> We will call this function \mintinline{racket}{copier} and it will have the same functionality as \mintinline{racket}{make-list}.
  \item<5-> Let's start designing it with a header.
  \item<6-> \copierHeader
  \item<7-> Wouldn't it be nice to say that we return a list of
    type \mintinline{racket}{List<T, n>} where n indicates that
    we have a list of length n?
  \end{itemize}
\end{frame}

\defverbatim[colored]\CopierExamples{
\begin{minted}[fontsize=\footnotesize]{racket}
(check-expect (copier 0 "w") '())
(check-expect (copier 1 "w") '("w"))
(check-expect (copier 2 "w") '("w" "w"))
\end{minted}
}

\defverbatim[colored]\CopierSkeleton{
\begin{minted}[fontsize=\footnotesize]{racket}
    (define (copier n item)
      (cond
        [(zero? n) ...]
        [(positive? n) n ... (copier (sub1 n) item) ...]
\end{minted}
}

\begin{frame}
  \frametitle{Copy That}
  Back on to writing our copy function, let's provide some functional
  examples as tests:
  \CopierExamples
  \begin{itemize}
  \item<2-> Recall that for providing our skeleton for natural recursion over lists, we had a template. The template for natural numbers is the same except that we replace \mintinline{racket}{empty?} with \mintinline{racket}{zero?} and \mintinline{racket}{(rest param)} with \mintinline{racket}{(sub1 param)}
  \item<3-> Thus, concretely for this program we have:
    \CopierSkeleton
  \item<4-> One thing different about this program from previous ones
    is that we have to remember the extra argument that does not change.  
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Copy That}
  Later we will discuss ways to where you don't have to worry about putting unchanging arguments in recursive calls.
  \begin{itemize}
  \item<2-> From our functional example, what should the result be
    when n is 0?
  \item<3-> It should be the empty list, so we can  fill in the first ... with '()
  \item<4-> How do we build lists?
  \item<5-> We use \mintinline{racket}{cons}.
  \item<6-> What are we putting into the list?
  \item<7-> Whatever is in \mintinline{racket}{item}.
  \item<8-> So, should we do something like
    \mintinline{racket}{(cons item ...)}.
  \item<9-> What goes in the ...?
  \item<10-> Well some sublist should be being built there.
  \end{itemize}
\end{frame}

\defverbatim[colored]\CopierFinal{
\begin{minted}[fontsize=\footnotesize]{racket}
    (define (copier n s)
      (cond
        [(zero? n) '()]
        [(positive? n) (cons s (copier (sub1 n) s))]))
\end{minted}
}

\begin{frame}
  \frametitle{Copy That}
  How did we build sublists in previous recursive functions?
  \begin{itemize}
  \item<2-> With the recursive call of course!
  \item<3-> We already had code for the recursive call, so we just
    place it where the ... was:
    \mintinline[fontsize=\footnotesize]{racket}{(cons item (copier (sub1 n) item))}
  \item<4-> This completes the cond for whole numbers and completes
    the function:
    \CopierFinal
  \item<5-> So, previously we had a function that took in lists and
    produced numbers and now we have a function that took in a number and produced lists.
  \item<6-> Let's consider an example without cross cutting between data types. How do we implement an addition function recursively without using +, and only using \mintinline{racket}{add1}?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Defining Addition}
  So, we can either build our result by destructuring
  x or destructuring y.
  \begin{itemize}
  \item<2-> If we recall grade school we can think of putting
    tallies together.
  \item<3-> But we need to decide whether we move tallies from x to
    y or y to x.
  \item<4-> Let's move from x to y.
  \item<5-> Let x = 3 and y = 2, then we have !!! + !!
  \item<6-> We remove a tally from x and go to !! + !!!
  \item<7-> Then ! + !!!!
  \item<8-> Then  we finally have !!!!! as our answer.
  \end{itemize}
\end{frame}

\defverbatim[colored]\addSkeleton{
\begin{minted}[fontsize=\footnotesize]{racket}
(define (add x y)
  (cond
    [(zero? x) ...]
    [(positive? x) ... (add (sub1 x) y) ...)])
\end{minted}
}

\begin{frame}
  \frametitle{Defining Addition}
  We have the following skeleton:
  \addSkeleton
  \begin{itemize}
  \item<2-> Think about left identities. What is 0+y?
  \item<3-> Ok, so our recursion terminates by giving us y:
    \mintinline{racket}{[(zero? x) y]}
  \item<4-> For our recursive case, our intution is that we
    ``break off'' a tally from x and ``add it on'' to y.
  \item<5-> We can think of breaking off a tally from x as:
    \mintinline{racket}{(sub1 x)}
  \item<6-> Thankfully this is already in our skeleton. Now how do I
    add a tally on to y?
  \item<7-> \mintinline{racket}{(add1 y)}
  \item<8-> We can write:
    \mintinline{racket}{[(positive? x) (add (sub1 x) (add1 y))]}  
  \end{itemize}
\end{frame}

\defverbatim[colored]\addNatural{
\begin{minted}[fontsize=\footnotesize]{racket}
(define (add x y)
  (cond
    [(zero? x) y]
    [(positive? x) (add1 (add (sub1 x) y))])
\end{minted}
}

\defverbatim[colored]\addTail{
\begin{minted}[fontsize=\footnotesize]{racket}
(define (add x y)
  (cond
    [(zero? x) y]
    [(positive? x) (add (sub1 x) (add1 y)))])
\end{minted}
}

\begin{frame}
  \frametitle{Defining Addition}
 Is this correct?
 \textbf{Yes, but it's a bit unnatural.} Why?
  Previously we would combine the result of the recursive call with
  something outside of the recursive call. Here a result is being
  produced inside the recursive call, as an argument.
  \begin{itemize}
  \item<2-> The natural version of our add function is:
    \addNatural
  \item<3-> Here was our original unnatural version:
    \addTail
  \item<4-> Which of these is preferred?
  \item<5-> Suprisingly, the unnatural version.  
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Addition Performance}
  The natural version is probably the better definition
  to start with, but you actually want to refactor to the unnatural
  version after you're confident that the natural version is
  correct.
  \begin{itemize}
  \item<2-> Why?
  \item<3-> \textbf{Performance!}
  \item<4-> Why is it more performant?
  \item<5-> Recall what you know about stack frames and recursion.
  \item<6-> The natural version must hold onto stack frames so that
    as the recursion unwinds we can return to earlier stack frames
    that held different copies of the parameters.
  \item<7-> In our unnatural version we do not need to remember old copies
    of our parameter value.
  \item<8-> By updating the parameter at each call, we can ``throw away''
    the old stack frame and just repeatedly create one new stack frame
    for each recursive call. In reality we can compile this into a loop.
  \item<9-> A general version of this is called \emph{tail recursion}
  \end{itemize}      
\end{frame}

\begin{frame}
  \frametitle{On Tail-Recursion}
  A tail-recursive call is one in which we do not need to combine
  the recursive call with some result.
  \begin{itemize}
  \item<2-> Consider: \mintinline{racket}{(add1 (add (sub1 x) y))}
  \item<3-> We must increment the result of each recursive call. This
    becomes (add1 (add1 (add1 ...)))
  \item<4-> We must keep storing stack frames and returning the result
    outwards.
  \item<5-> With: \mintinline{racket}{(add (sub1 x) (add1 y))}
  \item<6-> We get (add x1 y1) goes to (add x2 y2) goes to (add x3 y3)
    until (add 0 yn) at which we return yn as the answer directly.
  \item<7-> Hence we do not need to repeatedly remember the result of
    each recursive call for later computation.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Moving to Tail Recursion}
  In general we can move a function to being tail recursive with the
  following pattern:
  \begin{enumerate}
  \item<2-> Define an inner function that can only be called in an outer
    funciton
  \item<3-> Let this inner function take in the same parameters as the outer
    function \emph{plus} an addition parameter called \mintinline{racket}{accum}
  \item<4-> Move your combinator function from working on the outside of the recursive call to combining accum with some other value
  \item<5-> Define the body of the function with the normal skeleton except
    that you replace the base case value with \mintinline{racket}{accum}
  \item<6-> After this function is defined, call the inner function with
    your normal arguments and your base case value is the argument to
    \mintinline{racket}{accum}  
  \end{enumerate}
  \begin{itemize}
  \item<7-> This is rather abstract so let's consider our \mintinline{racket}{total} function
  \end{itemize}
\end{frame}

\defverbatim[colored]\totalReg{
\begin{minted}[fontsize=\footnotesize]{racket}
(define (total a-list)
  (cond
    [(empty? a-list) 0]
    [(cons? a-list) (+ (first a-list) (total (rest a-list)))]))
\end{minted}
}

\defverbatim[colored]\totalTail{
\begin{minted}[fontsize=\footnotesize]{racket}
(define (total-tail a-list)
  (define (total-inner a-list accum)
    (cond
      [(empty? a-list) accum]
      [(total-inner (rest a-list) (+ (first a-list) accum))]))
  (total-inner a-list 0))
\end{minted}
}

\begin{frame}
  \frametitle{Making Total Tail Recursive}
  Here is the regular version of total:
  \totalReg \\
  \pause
  Here is the tail-recursive version:
  \totalTail \\
  \pause
  Let me point out the differences.
\end{frame}

\begin{frame}
  \frametitle{Tail Recursion in General}
  My recommendation is not to worry about tail recursion until it becomes a bottlenceck in your application:
  \begin{itemize}
  \item<2-> Remember that premature optimization is the root of all evil.
  \item<3-> So, if you see that you have a serious bottleneck, try to follow the recipe I laid out.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Lists of Structs}
  Let's consider writing a program dealing with file IO for the first time in a long time. Assume we have a file with employee data on each line, separated by spaces. We have the
  employee's name, the number of hours they worked, and then finally their hourly pay rate. They can only work between 0 and 80 hours. If they work more than 40 hours, they make 1.5 times as much per hour per each hour past 40. Write to another
  file the employee name and how much they're owed. Then finally return the total
  amount the company must pay. Give an error message if hours or pay rate are negative. Give a separate error if someone worked more than 80 hours. Assume the input file is formatted correctly. 
  \begin{itemize}
  \item<2-> Woo we are back in 150/260!
  \item<3-> But we are only just now getting all the tools we need to write
    such programs from scratch (assuming there weren't already library functions for things like summing, etc.)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Scripts Revisited}
  Assume we can put employee data into a struct:
  \mintinline{racket}{(struct employee-data [name hours rate] #:transparent)}.
  \begin{itemize}
  \item<2-> Assume that we also have another struct for wage data:
    \mintinline{racket}{(struct wage-data [name wage] #:transparent)}
  \item<3-> In order to do the file IO part we will play around with the following functions: read-lines, read-words, and read-words/line
  \item<4-> But to start writing this program we can instead start with the pure core and just assume that we start off with a list of employee data.
  \end{itemize}
\end{frame}

\end{document}
%%% Local Variables:
%%% TeX-command-extra-options: "-shell-escape"
%%% mode: latex
%%% TeX-master: t
%%% End:
